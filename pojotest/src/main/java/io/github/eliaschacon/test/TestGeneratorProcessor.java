package io.github.eliaschacon.test;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.ElementKind;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.util.ElementFilter;
import javax.tools.JavaFileObject;
import java.io.IOException;
import java.io.Writer;
import java.lang.annotation.Annotation;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

@SupportedAnnotationTypes({"io.github.eliaschacon.test.TestGenerator", "io.github.eliaschacon.test.DTO"})
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public class TestGeneratorProcessor extends AbstractProcessor {

    private static final Logger logger = LoggerFactory.getLogger(TestGeneratorProcessor.class);

    private static final String NEW_LINE = "\n";
    private static final String DOUBLE_LINE = NEW_LINE + NEW_LINE;


    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {
        final var elements = new HashSet<Element>();
        elements.addAll(roundEnv.getElementsAnnotatedWith(TestGenerator.class));
        elements.addAll(roundEnv.getElementsAnnotatedWith(DTO.class));
        elements.stream()
                .filter(element -> element.getKind() != ElementKind.ANNOTATION_TYPE)
                .forEach(this::process);
        return true;
    }

    private boolean mustSkip(String prop, String[] skip) {
        return Arrays.asList(skip).contains(prop);
    }

    private boolean mustSkip(Annotation annotation, Element type) {
        final var prop = type.getSimpleName().toString();
        if (Objects.isNull(annotation)) {
            return false;
        }
        if (annotation.annotationType().equals(DTO.class)) {
            return mustSkip(prop, ((DTO)annotation).testSkip());
        }
        return mustSkip(prop, ((TestGenerator)annotation).skip());
    }

    private boolean mustSkip(Element element, Element type) {
        return
            mustSkip(element.getAnnotation(TestGenerator.class), type) ||
            mustSkip(element.getAnnotation(DTO.class), type);
    }

    private void process(Element element) {
        if (element.getKind() != ElementKind.CLASS) {
            return;
        }

        final var classElement = (TypeElement) element;
        final var className = classElement.getSimpleName().toString();
        final var packageName = classElement.getQualifiedName().toString().replaceAll("(.*?)\\." + classElement.getSimpleName(), "$1");
        final var testClassName = className + "Test";
        final var objName = className.toLowerCase();

        try {
            JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(packageName + "." + testClassName);
            try (final var writer = sourceFile.openWriter()) {

                writer.write(String.format("package %s;%s", packageName, NEW_LINE));
                writer.write(String.format("%simport org.junit.jupiter.api.Test;%s", NEW_LINE, NEW_LINE));
                writer.write(String.format("%simport static org.junit.jupiter.api.Assertions.*;%s", NEW_LINE, DOUBLE_LINE));
                writer.write(String.format("/**%s * Class autogenerated by TestGenerator for POJOS. %s * Do not modify please!%s */%s", NEW_LINE, NEW_LINE, NEW_LINE, NEW_LINE));
                writer.write(String.format("class %s {%s", testClassName, DOUBLE_LINE));

                for (final var fieldElement : classElement.getEnclosedElements()) {
                    if ((fieldElement.getKind() != ElementKind.FIELD) || (mustSkip(element, fieldElement)) || (!ElementUtils.hasGetterAndSetter(classElement, fieldElement))) {
                        continue;
                    }

                    var fieldName = fieldElement.getSimpleName().toString();
                    var camelCased = fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);

                    writer.write(String.format("    @Test%s", NEW_LINE));
                    writer.write(String.format("    void shouldSetAndGet%s() throws Exception {%s", camelCased, NEW_LINE));
                    writer.write(String.format("        final var %s = new %s();%s", objName, className, NEW_LINE));

                    processField(className.toLowerCase(), camelCased, classElement, fieldElement, writer);

                    writer.write(String.format("    }%s", DOUBLE_LINE));

                }

                if (ElementUtils.hasHashCodeMethod(element)) {
                    writer.write(String.format("    @Test%s", NEW_LINE));
                    writer.write(String.format("    void shouldCheckHashCode() throws Exception {%s", NEW_LINE));
                    writer.write(String.format("        final var %s = new %s();%s", objName, className, NEW_LINE));
                    writer.write(String.format("        assertTrue(%s.hashCode() > 0);%s", objName, NEW_LINE));
                    writer.write(String.format("    }%s", DOUBLE_LINE));
                }

                writer.write(String.format("}%s", NEW_LINE));
            }
        } catch (IOException e) {
            logger.error(e.getMessage(), e);
        }
    }

    private void processField(String objName, String fieldName, Element typeElement, Element enclosedElement, Writer writer) throws IOException {
        final var getter = "get" + fieldName;
        final var setter = "set" + fieldName;

        final var params = ElementFilter.methodsIn(typeElement.getEnclosedElements()).stream().filter(element -> element.getSimpleName().toString().equalsIgnoreCase(setter)).findFirst()
                .map(ExecutableElement::getParameters)
                .map(variableElements -> variableElements.stream().map(Element::asType).collect(Collectors.toList()))
                .orElse(new ArrayList<>());

        final var values = new ArrayList<String>();
        for (final var o : params) {
            values.add(ElementUtils.getValue(o));
        }

        if (ElementUtils.hasGetterAndSetter(typeElement, enclosedElement)) {
            writer.write(String.format("        %s.%s(%s);%s", objName, setter, String.join(", ", values), DOUBLE_LINE));
            writer.write(String.format("        final var result = %s.%s();%s", objName, getter, DOUBLE_LINE));

            if (values.size() == 1 && !ElementUtils.isPrimitive(params.get(0))) {
                writer.write("        assertNotNull(result);" + NEW_LINE);
            }

            if (values.size() == 1 && !values.get(0).contains("new") && !values.get(0).contains("java.time") && !values.get(0).contains("Mockito.mock")) {
                writer.write(String.format("        assertEquals(%s, (%s) result);%s", values.get(0), params.get(0), NEW_LINE));
            }
        }
    }
}
